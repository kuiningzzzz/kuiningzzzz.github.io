内容较多建议使用Ctrl+f查找

## 语法查询：https://zh.cppreference.com/

## 注释

单行注释：//

多行注释：/\*       \*/

## main函数

一个程序的入口，每个程序都必须有，有且仅有一个

## 变量

给一个指定的内存空间起名，方便管理内存空间

创建语法：数据类型 变量名=变量初始值

如：`int a=10;`

## 常量

用于记录程序中不可更改的数据

定义方法：

1. 定义宏常量：`#define 常量名 常量值`（通常在文件上方定义）
   
   在数字后加：（不区分大小写）
   - L：长整型或双精度长型浮点
   - U：无符号整型
   - LU：无符号长整形
   - F：单精度浮点
   - 浮点型常量默认为double
2. constexpr修饰变量：`constexpr 数据类型 变量名=常量值`
3. const修饰（实际上并非常量，而是只读变量）

## 关键字

被语言征用的含有特殊含义的单词，自己不能再用来给变量和常量起名字

## 标识符命名规则（变量常量起名规则）

1. 不能是关键字
2. 只能由字母、数字、下划线组成
3. 第一个字符必须为字母或下划线，不能为数字
4. 字母区分大小写

## 数据类型

创建变量和常量的时候要指明数据类型，否则系统无法分配内存

数据类型的内存均为vs环境下的情况

1. 整型：（如果数值超过上限，会从下限重新计）
   - short短整型，2字节，表示-2的15次到2的15次-1 （32767）（实际是signed short int的缩写）
   - int整型，4字节，表示-2的31次到2的31次-1 （2147483647）
   - long长整型，windows4字节，Linux32位4字节64位8字节（实际是signed long int的缩写）
   - long long长长整型，8字节，表示-2的63次到2的63次-1
   - （加上前缀unsigned，则范围变为从0开始，unsigned表示无符号型）
2. 实型（浮点型）：
   - float单精度，4字节，7位有效数字
   - double双精度，8字节，15位有效数字
   - 一般编译器默认把float直接转化为double，所以定义float需要：`float a=3.14f`

   在不做其他配置的情况下一般运行后cout最多只会显示6位有效数字

   如需配置：在开头加入`#include <iomanip>`，加入一句`cout << setprecision(有效数字数)` 即可

   科学计数法：如`double a=3e-2`，表示3乘10的-2次方

   默认情况下小数末位数字0不会显示，如需固定显示小数的精度：`cout << fixed << steprecision(小数位数) << 变量;`
3. 字符型：只占用一个字节

   语法：`char 变量名=‘一个字符’`（必须用单引号）

   a-97 A-65

   0~31一般为控制字符，32~126是键盘上能找到的字符

   转义字符：表示一些不能显示出来的ASCII字符,一般由反斜杠\\和另一个字母组成
   - \\n：换行
   - \\t：水平制表（补齐8位可以整齐的输出数据）
   - \\\\：输出一个\\
   - \\a：输出一个铃声
   - \\r：回车
   - \\\'：单引号
   - \\\"：双引号
   - \\b：退格（backspace）
4. 字符串型：

   c语言风格字符串的沿用：`char 变量名[]="内容"`（必须用双引号）

   c++风格字符串：`string 变量名="内容"`（使用这个时，头文件要包含string，即在开头加入：`#include <string>`，vs自2019开始将此加入在std里了，不用再加入string头文件）

5. 布尔类型：代表真假，一个字节，只要是赋值非0，都会储存1

   true，真，本质是1

   false，假，本质是0

   语法：`bool 变量名=true或false`，输出的结果是1或0

6. auto关键字：（cpp特性）

   变量和函数声明时使用，编译器自动推导变量类型

   1. 必须定义时初始化
   2. 不能定义数组
   3. cpp20以前不能在函数参数中使用
   4. 可以使用const \* &等修饰符
   5. 无法推导数组或函数类型
   6. 不会主动推导const和引用类型
   7. 会主动推导指针类型
7. 为变量类型取新名字：

   `typedef 类型 新名字`

   `using 别名=原类型`

## 运算符

执行代码的运算

1. 算数运算符：

   - +：正号/加
   - -：负号/减
   - \*：乘
   - /：除（两个整型相除结果仍为整数，小数部分去除，并非四舍五入）（两个小数相除得到小数，四舍五入）（除数为0时会崩溃报错）
   - %：取余（必须是整数）（除数为0时会崩溃报错）

   优先级：括号最优先，乘除取余优先，加减次之，从左向右计算

   char,short在计算时转化为int型；float在计算时转化为double型

   其他不同数据类型之间进行运算时，数据类型会先发生转化再运算，转化关系为：

   int->unsigned->long->double

   - ++：递增 前置：在使用变量之前先进行+1  后置：在使用变量之后再进行+1
   - --：同理

   ++--只能用给变量，不能用于表达式，如(-i)++,(i+j)++,++i++等形式，编译器会报错（在某些语言中可以，但是c语言中不允许）

   输出++--时，在不同编辑器下情况不同。在vs编译器中，会从右往左进行计算，所以：`int a = 0;cout << a << a++;`会输出1 0

2. 赋值运算符：

   - =：赋值
   - +=：将等号后的值加入前面的变量中，本质为：a=a+某
   - -=：同理
   - \*=：同理
   - /=：同理
   - %=：同理

   当赋值运算符左右数据类型不同时，右侧数据会被转化成左侧数据类型并赋值给左侧

   当右侧内存长度大于左侧长度时，将较长的一侧从后部截断，将后部赋给左侧

   当右侧内存长度小于左侧长度时（如将short赋值给long）：

   1. 若short为无符号数（unsigned），则将short赋值给long的低十六位，高十六位用0补齐
   2. 若short为有符号数，则将short赋值给long的低十六位。若short最高位是0，则高十六位用0补齐；若short最高位是1，则高十六位用1补齐

   当有符号数和无符号数相互赋值时：直接将内存中的二进制数据复制进行赋值（当作无符号数）

   赋值语句也是表达式，有数值，数值为赋值传递的这个数值

   连续赋值：如a=b=c=5，连续赋值不能在定义变量时使用

   对于连续赋值的优先级，为从右向左，如a+=a-=a\*a，先算a=a-a\*a，再算a=a+a

3. 关系运算符：（符合时输出1，不符合时输出0）
   - \=\=：相等
   - !=：不相等
   - <：小于
   - \>：大于
   - <=：小于等于
   - \>=：大于等于

   后四者优先级高于前两者

   关系运算表达式的返回值为真或假

4. 逻辑运算符：
   - !：非，如`!a`，含义为：如果a为假则a为真，如果a为真则a为假
   - &&：和，如`a&&b`，含义为：只有ab都为真时才取真
   - ||：或，如`a||b`，含义为：只要有一个真就取真

   优先级：非大于与大于或

   短路求值：
   - 对于`a||b`，若a已经为真，则不会再去执行b的语句
   - 对于`a&&b`，若a已经为假，则不会再去执行b的语句

5. Sizeof运算符：统计数据类型所占内存的大小

   语法：`sizeof(数据类型或变量)`注：sizeof不是函数

6. 指针运算符\* &
7. 逗号运算符：

   用于连接不同的表达式，表示从左到右依次执行

   逗号表达式整体也有一个值，值为最后一个表达式的值

8. 条件运算符：三目运算符（? :）见下文
9. 强制类型转换运算符：

   `(目标类型)变量`

   变量的类型没有发生改变，只有该式的值发生类型改变

10. 运算符的优先级顺序：

      后置++ --

      高于 前置++ -- 逻辑非（！） \* &

      高于 算数运算符

      高于 关系运算符

      高于 && ||

      高于 赋值运算符

      高于 逗号运算符

      在相同优先级情况下，一般从右向左（即从离标识符更近的运算符开始计算） 

## 选择结构：根据条件，有选择的执行相应程序

if语句：

- 单行格式if：
   ```
   if(条件)
   {条件满足或输出值为真时执行的代码}
   ```
- 多条件if：
   ```
   if(条件1)
   {条件1满足或输出值为真时执行的代码}
   else if(条件2)
   {条件2满足或输出值为真时执行的代码}
   ......
   else
   {条件都不满足或输出值为都假时执行的代码}
   ```
- 嵌套if：if语句中再次插入if

三目运算符：

- 语法：`表达式1?表达式2:表达式3`
- 含义：如果表达式1为真，则执行2，否则执行3
- 可作右值：c=(a>b?a:b)，表示c取较大的值
- 可作左值：(a>b?a:b)=100，表示将较大的值赋值为100

switch语句：（缺点：判断时只能是整型或字符型，不可以是一个区间）（优点：结构更为清晰，执行效率高速度快）
   语法：（如果不加break，会默认将此条case的下面所有程序运行一遍）
   ```
   switch(表达式)
   {
   case 结果1:
   执行语句;
   break;
   case 结果2:
   执行语句
   break;
   ......
   default:
   执行语句
   }
   ```

## 循环结构

while语句：（执行完后再次判断条件，若还满足则继续执行）（避免死循环否则程序会一直运行不停，必须提供一个退出循环的出口）
```
while(循环条件)
{要执行的循环语句}
```

do...while语句：（会先执行一次语句，再进行循环判断）
```
do
{执行的语句}
while(循环的条件)
```

for循环语句：（优点：结构更清晰）

`for(起始表达式;条件表达式;末尾循环体){执行循环语句}`（分号间隔的这三个表达式可以为空）

起始表达式不参与循环，用于做变量的赋值和声明等

条件表达式是循环的条件

末尾循环体是每次循环之后都额外进行一次的循环语句

基于范围的for循环：（c++风格）

如：`for(int x : 数组/容器){}`（功能类似于python的for），使用迭代器实现，{}内的x只是形参，无法修改实际元素，如需修改，应传入引用，即int& x

嵌套循环：循环套循环，外层每执行一次，内层会执行一周

## 跳转语句

break语句：跳出选择结构和循环结构

使用时机：

1. 出现在switch中：终止case并退出switch
2. 出现在循环语句中：跳出当前循环
3. 出现在嵌套的内层循环中：跳出当前的内层循环

continue语句：在循环语句中，跳过本次循环剩下没执行的语句，继续下一轮循环

goto语句：无条件跳转语句
- 语法：goto 标记
- 若标记存在，执行到goto时会跳转到标记处
- 优点：功能强大
- 缺点：使代码结构混乱不易阅读
- 不要使用！
- 标记：标记名:    （加冒号）

## 数组

一个集合，存放了相同类型的数据元素

特点：1，每个元素的数据类型相同 2，由连续的内存储存

**一维数组**定义方式：（定义数组时必须有初始长度，初始长度必须为常量表达式）

法1：`数据类型 数组名[数组长度];`

法2：`数据类型 数组名[数组长度]=\{值1,值2,......\};`（若未补齐，剩下的会用0填充定义）

法3：`数据类型 数组名[]={值1,值2,......};`（数组长度自动计算）

在数组中，每个数据可以被 `数组名[下标]` 的形式访问，下标是按顺序从0开始索引的

用途：

1，结合sizeof()可以获取整个数据所占用内存空间

2，数组名就是数组第一个元素的地址，对于数组a[]，a即为&a[0]

数组名是常量，不能再进行赋值，不可修改

表示数组元素个数：`sizeof(数组名)/sizeof(数组名[0])`

表示末位元素下标：`sizeof(数组名)/sizeof(数组名[0])-1`

**二维数组**：有行有列，呈矩阵

定义方式：

1，`数据类型 数组名[行数][列数];`

2，`数据类型 数组名[行数][列数]={{数据1,数据2,...},{数据3,数据4,...},...};`（大括号个数表示行数，大括号内数据数表示列数）

3，`数据类型 数组名[行数][列数]={数据1,数据2,数据3,数据4,...};`（程序自动区分行列）

4，`数据类型 数组名[][列数]={数据1,数据2,数据3,数据4,...};`（程序自动区分行列和行数）

二维数组中a[0]表示第一行，a[0][0]才表示第一个数据

**字符型数组**：

未初始化的字符型数组内的成员默认为\0（asc码中的第一个字符，是一个结束标志）

一种定义方式：`char a[]=”China”`，此定义使该数组有六个元素，C h i n a \0

所有字符串都是以\0结尾的字符数组

所有以\0结尾的字符数组都是字符串

这种方式只有在定义的时候可以使用，不能用于将字符串赋值于字符数组或者将字符数组赋值于字符数组

## 函数

作用：将一段经常使用的代码封装起来，减少重复代码

一个较大的程序，一般分为若干的模块，可以封装为函数

定义方式：
1. 返回值类型
2. 函数名
3. 参数表列
4. 函数体语句
5. return表达式

语法：
```
返回值类型 函数名(参数表列)
{
    函数体语句
    return表达式（一般与前面返回值类型挂钩）
}
```

（如果函数不需要返回值，返回值类型可以写void，return后不加内容或不需要写return）

**函数的调用**：

语法：`函数名(参数)`

调用时，定义函数内的变量无实际值，称为形参，参数表列也成为形参表列

调用带入的变量有实际意义，称为实参

**值传递**：

调用函数时实参的值会传递给形参

值传递时如果形参发生任何改变，不会影响到实参

函数的常见样式：

1. 无参无返，如：仅打印一行话  
   调用：直接函数名()即可
2. 有参无返，如：打印一句含参数的话  
   调用：函数名(实参)
3. 无参有返  
   调用：可用作数据接收，如：`int num=函数名()`
4. 有参有返

**函数的声明**：

在函数定义之前，先告诉编译器该函数的存在

当函数的定义在main函数之后时系统会找不到函数，将函数的声明放在main之前，系统就会向下寻找函数

语法：`返回值类型 函数名(形参列表);`

函数的声明可以多次，但是定义只能一次

**函数的类型**：由函数的返回值类型、参数类型共同决定，如int(int,int)

可以使用using为函数类型起别名

函数可以嵌套调用，但是不能嵌套定义

**递归调用**：

一个函数在定义时，直接或间接调用自己的一种方法

常见的用途：

1. 用递归完成递推数列
   1) 关注点放在要求解的目标上
   2) 搞清递推式（如n和n-1项的关系）
   3) 搞清首项的值

2. 模拟连续发生的动作（如：二进制转换，汉诺塔问题）
   1) 搞清楚连续发生的动作是什么
   2) 搞清楚不同次动作之间的关系（如上一次的返回值用于下一次的某个运算）
   3) 搞清楚边界条件（首项）

3. 进行自动的分析：
   1) 先假设存在这么一个函数能够给出答案
   2) 在这个函数的辅助之下分析如何解决问题
   3) 搞清楚最简单的情况下答案是什么，类似于数列的首项

示例代码：
```cpp
double solver()
{
    char in[20];
    cin >> in;
    switch (in[0])
    {
    case '+':return solver() + solver();
    case '-':return solver() - solver();
    case '*':return solver() * solver();
    case '/':return solver() / solver();
    default:return stof(in);
    }
}

int main()
{
    cout << solver();
    system("pause");
    return 0;
}
```
（此代码用于计算逆波兰表达式的结果）



## 指针（pointer，常用p表示）

指针：一个地址

一个变量的地址就是“指向这个变量的指针”

指针变量：一个数据内容是指针（地址）的变量

作用：通过指针间接访问内存

内存有地址编号，从0开始，一般用16进制数字表示

可以用指针变量保存地址

**定义指针**：

`数据类型 * 指针变量名=&变量名`

此时，该指针变量称为指向这个变量的指针变量

在定义式中，\*表示变量的数据类型为指针，数据类型表示该指针变量的基类型，即该指针变量所指向的变量的类型

**使用指针**：通过解引用的方式找到指针指向的内存中的数据

指针运算符（*）：用于访问其后地址中的内容

解引用：`*指针名`（指针前加*，表示解引用，找到地址中的数据）

**空指针**：指针变量指向了内存中编号为0的空间

用途：初始化指针变量

空指针指向的内存空间是不可访问的（0~255是系统占用的内存，不可以访问）

定义方法：`数据类型* 指针变量名=NULL;`（NULL表示0）（或nullptr，这是C++风格）

一般习惯对指针变量进行初始化，否则未知其所代表的地址，进行操作时会比较危险

指针所占的内存空间：32位系统占4个字节，64位系统占8个字节

**野指针**：指针指向非法的内存空间

如：`int* p=(int*)0x1100`（随便写的地址，未申请使用）

这是错误，程序中要尽量避免出现野指针

野指针也不能访问

**const修饰指针**：

1. const修饰基类型，成为指向符号常量的指针，如：`const int*p=&a`，指针的指向可以修改，指针指向的值不可以改，可以用于作为函数的形参，防止函数意外修改了数据
2. const修饰常量，成为指针常量，如：`int * const p=&a`，指针的指向不可以改，指针指向的值可以改
3. const既修饰指针又修饰常量，如：`const int * const p=&a`，指针的指向和值都不可以改

**指针与数组**：利用指针访问数组中的每个元素

```cpp
int arr[10]={1,2,3,4,5,6,7,8,9,10};
int * p=arr;    // arr就是数组的首地址
p++;           // 让指针向后偏移一个数据
```

注意：
- 数组名arr表示指向数组首元素的指针
- 而&arr表示指向整个数组的指针
- 就地址而言两者相同
- 但对其进行+1操作，前者跳过的是第一个元素，后者跳过的是整个数组
- &相当于将访问权限上调一级，而*相当于把访问权限降低一级

对于二维数组：

数组实际上由a\[0\],a\[1\],a\[2\],...组成，第一个元素为a\[0\]，实际上是一个小数组，此时a的含义是指向整个小数组的指针，而a\[0\]的含义是指向a\[0\]\[0\]这个变量的指针。此时按照管辖范围不同可以排列出从大到小：&a,a,a\[0\],a\[0\]\[0\]，这四者均可以用&和\*进行升级降级。多维数组同理。

例如：对于int a\[3\]\[4\]，a的类型为：int (\*p)\[4\]，是一个表示指向四个元素的小数组的指针

**指针与函数**：令指针作为函数的形参：**地址传递**（不再是值传递），此时实参可以被形参修改和影响

在传递一个二维数组名作为指针变量时，形参列表应该设置为int (\*p)\[4\]类或int a[][4]类

可以直接将数组名传递给函数作为实参，此时形参可设置为int a\[\]类，c++编译器会把数组名当作指针变量进行操作，而正常情况下数组名是常量不允许改变

需要返回值为指针时：在函数名前加上\*符号即可，前面加上指针的基类型

此时需要注意：这个返回的指针需要有意义，不能因函数结束后内存释放掉而失去原来存储的意义，即应警惕局部变量失去作用域。一般有两种方法：

1. 使用全局变量
2. 定义一个静态局部变量（如：`static int a`），静态局部变量不会随着函数内存的释放而消失，其存在一直持续到程序的结束

利用指针，函数，数组，完成数组中数据的顺序排列：

此处函数必须用指针，因为只有地址传递才能改变实参

冒泡排序函数示例代码：
```cpp
void bubblesort(int* arr, int leng)
{
    int temp = 0;
    for (int i = 0; i < leng - 1; i++)
    {
        for (int j = 0; j < leng - i - 1; j++)
        {
            if (arr[j] > arr[j + 1])
            {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
```

调用时只需要：`bubblesort(数组名,数组长度)`

**指针变量的++--运算**：

跨过该指针变量的基类型的内存空间，指向此内存空间的下一个内存位置或上一个内存位置

注意：指针变量可以这样操作至数组之外，此时操作会非常危险，在进行访问甚至改变时可能会破坏内存

`指针变量[i]`，表示`*(指针变量+i)`

**指针与字符串**：

字符数组的`cout << 数组名`语句不再输出地址，而是输出该字符串，且`cout<<数组名首地址的指针`，也会输出该字符串

若要输出字符数组首地址，语法为：

`cout << static_cast<void*>;`(数组名或首地址的指针)

可以直接对指针赋值字符串常量，如：

char \* pc;

pc = “hello”;

此时指针指向这个字符串常量，可以访问，但不能修改

若：cout<<pc，会得到hello

pc++;cout<<pc，会得到ello

cout<<\*pc，会得到e

## 结构体

用户自定义的数据类型，允许用户存储不同的数据类型

**结构体定义**：`struct 结构体名{结构体成员列表};`

例：
```cpp
struct Student
{
    string name;
    int age;
    int score;
};  // 注意此处要有一个分号
```

**创建具体的变量**：（创建变量时struct可以省略）

1. `struct 结构体名 变量名`
2. `struct 结构体名 变量名={内容}`
3. 在定义时创建（很少用，不建议）

例：
```cpp
struct Student s1;
struct Student s2={"李四",18,90};

struct Student
{
    string name;
    int age;
    int score;
}s3;
```

**访问其具体的属性**：

`变量名.结构体成员名`

例：
```cpp
s1.name="张三";
s1.age=18;
```

**赋值**：`变量名1=变量名2`，意义为将变量2的信息复制一份给变量1

**结构体数组**：

将自定义的结构体放入数组中便于维护

语法：`struct 结构体名 数组名[元素个数]={{},{},{},......}`

访问：`数组名[编号].结构体成员名`

**结构体指针**：

利用`->`（操作符）可以通过结构体指针访问结构体属性

将指针指向结构体变量：
`struct 结构体名* 指针名=&变量名`

通过指针访问结构体变量：
`结构体名->结构体成员名`（指向运算符）

结构体嵌套：

```cpp
struct 结构体2
{
    // 成员定义
};

struct 结构体1
{
    struct 结构体2 成员名;
};
```

访问：变量名.结构体成员名1.结构体成员名2

结构体作为函数参数向函数中传递

值传递：将该结构体中的数据copy一份作为函数的实参

地址传递

结构体作为函数返回值：将返回值copy一份返回

结构体中的const：

限制只读状态防止误操作

函数中为了避免值传递时将一个变量所有的属性代入函数而引起的内存占用过大，可以使用地址传递（因为指针只占4字节，且不会复制一个新的副本）

此时可以在定义函数时的形参前加上const，若有修改行为会报错，避免造成数据修改



## 系统函数/DOS指令

在代码中`system("")`内输入指令即可

- `cls`：清屏操作
- `pause`：请按任意键继续



## cin流

**输入过程**：

1. 输入内容，回车
2. 内容连带着回车，一起进入输入缓冲区内存中的一个池
3. 程序到缓冲区里获取相应的字符
4. 读取程序的指针记录读取到的位置，只能往后走，不能往前走

**cin与>>运算符**：

cin会认为，空格或回车是间隔不同的变量值的标志，在字符中会跳过空格和回车

当输入字符串时，>>跳过空白符，读取后面非空白符直到遇到下一个空白符，并在串尾放一个字符串结束标志

若不用回车作为结束标志，可以使用Ctrl+Z结束输入

**cin.get()函数**：（点（.）代表这个函数是cin这个对象的一个方法）

可用于读取一个字符（char类型）：

示例代码：
```cpp
while ((c=cin.get())!=EOF)
    cout << c;
```

或：
```cpp
char c;
while(cin.get(c))
    cout << c;
```

含义为：只要没有出现文件结束标志，就一直输出键入的字符

此函数可以读取输入的空格和回车

可用于读取一串字符：

cin.get(x,y,z)：x为字符数组名，y-1是读取的字符数，z是终止标志

示例代码：

cin.get(ch,10,’o’)：表示读取9个字符放入变量ch中，且遇到o时读取停止，此时指针在缓冲区的终止字符之前

cin.getline(x,x,x)的用法与cin.get(x,x,x)完全相同，但是遇到终止字符后，指针停在缓冲区终止字符之后

第三个参数若不写，则默认为换行符（回车）

getline()：一般写作getline(cin,string型变量名)

getchar()函数：

不跳过任何字符，包括Ctrl+z打出的字符

输入单个字符

cin >> 数组名，可以直接输入一串字符，这种方式只能用于字符数组

cin.ignore(int型 char型)：忽略缓冲区的字符，忽略int个且遇到char字符时提前停止，不输入参数时默认为(1 EOF)，常用于吃掉上次输入后缓冲区剩下的回车字符，避免对下次输入产生影响（设置为(足够大的数 \n)）



## 一些cin/cout流控制符

cout：

dec：输出十进制数字

hex：十六进制

oct：八进制

cin：

noskipws：不会过滤掉不可见字符



## 数学运算库（cmath）

使用：

`#include <cmath>`

内容：

三角函数：

- sin(弧度制数据)
- cos()
- tan()
- acos(数值)：反余弦
- asin()
- atan(x)
- atan2(x,x)：反正切，返回y/x反正切的主值

双曲函数：

- cosh(双曲线角度的值)：计算双曲余弦
- sinh()，tanh()，acosh()，asinh()，atanh()

指数对数：

- exp()：计算e的某次方
- exp2()：计算2的某次方
- log()：计算自然对数
- log10()：计算常用对数
- log2()：计算以2为底的对数

幂函数：
- pow(底数,指数)
- sqrt(被开方数)
- cbrt(被开立方数)

舍入函数：

- ceil()：向上取整
- floor()：向下取整
- trunc()：向0舍入
- round()：四舍五入
- abs()：绝对值

## string库的一些用法和函数

string为一个模板类，实际上是`basic_string<char>`

string的常用初始化：`string a("")`，`string a=“”`，`string a(n,"")`（无法用字符和数字初始化，但是可以将字符赋值给字符串变量）

字符串字面量类型推导：“aaa”类型为`const char*`，“aaa”s类型为`string`（需要使用`using namespace std::literals`）

string可以cin和cout，可以getline(cin,string变量)

成员函数：

`length()`/`size()`读取长度

`empty()`检查是否无字符

`capacity()`返回当前对象可存储的字符数量

支持下标[]运算

`at(i)`，效果同下标运算，但是会做范围检查，i超出范围时会抛异常

支持`=`赋值

`assign()`也可以赋值

`+/+=`连接字符串

`append()`连接字符串

`substr()`子串

\=\= > >= < <= != `compare()`

`find()` `rfind()` `find_first_of()` `find_last_of()`

`erase()`删除

`replace()`替换

`insert()`插入

`strcat(x,y)`：拼接两个字符串

`strcpy(x,y)`：用于字符串赋值（令x等于y）

`strlen()`：求一个字符串的长度

`atoi()`：将字符型的数字转化为整型的数字

`atof()`：将字符型的数字转化为浮点型的数字

`stoi()`：将字符串型的数字转化为整型的数字

`stof()`：将字符串型的数字转化为浮点型的数字

`strcmp()`：比较两个字符串的大小，前大返回1，后大返回-1，等于返回0

`strtok(char\*p1,char\*p2)`：对p1字符串从头开始寻找，当元素为p2中的某一个时，截断，返回一个指针指向前半部分的字符串，若没找到则返回NULL。此时strtok指在后半部分，若要继续截断，则使用strtok(NULL,char\*p2)。注：strtok函数会将原p1字符串中的截断点替换为、0，即改变了字符串，若p1为字符串常量，则会报错。若第一个字符为截断点，则会直接跳过。

字符串的流处理

使用`istringstream`和`ostringstream`进行字符串上的输入输出（在`<sstream>`库中）



## 位运算

位运算：指进行二进制位的运算

位运算运算符：

双目：（不同长度的数据进行位运算时，按右侧对齐进行计算，左侧补位：若无符号或有符号为正，则补0；若有符号为负，则补1）

按位与：&，将参与运算的数据各个二进制位独立进行与运算

按位或：|，将参与运算的数据各个二进制位独立进行或运算

按位异或：^，将参与运算的数据各个二进制位独立进行异或运算（异或：相同则为0，不相同则为1）

单目：

取反：~，把数据的每一位进行取反

左移：<<，将数据左移若干位，左侧溢出的数据舍弃，右侧空出的位置补0，在溢出的数据全为0时，本质相当于对数据乘2的n次方

右移：>>，将数据右移若干位，右侧溢出的数据舍弃，左侧空出的位置补0，在溢出的数据全为0时，本质相当于对数据除以2的n次方

位运算也可以和赋值运算符组合，如&=，|=等

位运算的优先级：

取反 高于 算数运算 高于 左右移 高于 关系运算 高于 按位与 高于 按位异或 高于 按位或 高于 逻辑运算

位运算常见用途：

按位与：

1. 与0按位与可以对数据清零
2. 取一个数的指定位，将0对应的位变为1并与待测数进行按位与运算，即可获得。如：0000000011111111可以获得一个16位数据的后八位数据

按位或：

与1按位或可以对数据全赋予为1

异或：

1. 使特定位反转，将对应位设置为1并与待测数进行按位与运算，即可获得。如：00001111可以获得一个后四位反转的数据
2. 使特定位不变，将对应位设置为0并与待测数进行按位与运算，即可获得。如：11110000可以获得一个后四位不变的数据
3. 用于互换两个数的值：对于a、b，使用：a=a^b;b=b^a;a=a^b;即可完成



## time.h库

mktime(tm\*类型)：将struck tm的指针类型变量转化为时间戳time\_t类型，同时根据需要修改正确的tm\_wday和tm\_yday

（struck tm：成员：

tm\_sec：秒

tm\_min：分

tm\_hour：小时

tm\_mday：月中的天

tm\_mon：月（0到11）

tm\_year：年（1900年为0）

tm\_wday：周中的天

tm\_yday：年中的天

localtime(time\_t\*类型)：将时间戳转换成本地时间（struct tm格式）



## 引用

语法：`int& 变量名=变量` / `int (&数组引用名)[]=数组名`

公用同一块内存，必须初始化，不能赋空值

**常用操作**：
1. 将引用作为函数参数，可以像地址传递一样实现实参的改变

2. 将引用作为返回值类型，实现返回值的赋值

如：
```cpp
int n=1;
int & func()
{return n;}

int main()
{
    func() = 4;        // 此时n被赋值为4
}
```

## 内存动态分配

语法：`指针变量=new 变量类型`：申请变量类型大小的动态分配的内存给指针

分配一个数组：`指针变量=new 变量类型[n]`

使用new后必须使用delete释放内存，同一块内存不能delete多次

语法：`delete 指针变量` / `delete[] 指针变量` （释放数组）

## 内联函数

在函数定义时在函数前面加上关键字inline，使编译器在遇到函数时不再调用，而是直接将函数体语句加入到调用处的程序中，节省系统开销

声明在类内的函数必须加inline才是内联函数，但定义在类内的函数默认为内联函数

## 函数重载

同函数名的函数，参数列表中形参的数量、类型不同，调用时系统会调用符合要求的特定函数

注意避免出现二义性

复杂情况：

T和const T视为一种

T\*和T\* const视为一种

T&和const T&视为两种

T\*和const T\*视为两种



## 函数缺省

函数定义时，最后几个形参可以赋默认值，调用时可以不填入参数，不填的参数必须全部位于最右侧，不能有空参数



## 面向对象、类、实例

类：归纳一类事物的属性和行为，抽象出一个数据结构

实例： 类实例化出的对象

语法：
```cpp
class 类名
{
private:    // 只能在成员函数内访问，类内定义未写权限时，默认是private
            // 强制对成员变量的访问一定要通过成员函数进行；方便修改成员变量的类型等属性 只需更改成员函数，否则, 所有直接访问成员变量的语句都需要修改

public:     // 在任何地方都可以访问
    属性;
    方法(){}

protected:  // 在类内和private一致，区别在于对子类的权限
};
```

```cpp
类名 对象名;                  // 实例化对象
对象名.方法名();              // 调用类内方法或属性
对象指针名->方法名();         // 通过指针调用类内方法或属性
```

类的成员函数可以不在类内定义，而只写声明，在类外通过`类名::成员函数名`定义

可以用struct代替class定义类，区别是未写权限时默认为public

构造函数：类内的一个成员函数，不能有返回值类型（void也不行），名字与类名同名，没有定义时系统自动为类生成一个没有作用的构造函数（有定义时，可以重载一个原先默认的构造函数：类名()=default;）

构造函数用于对象进行初始化，如赋初值

对象生成时，自动调用构造函数，此后无法再调用构造函数

一个类可以有多个参数类型或参数数量不同的构造函数

构造函数有参数时，实例化对象时须在对象名后加 (实参)，实例化对象数组时，单参数使用 {参数,参数,...}，多参数时使用 {类名(参数,参数,...), 类名(参数,参数,...),...}

构造函数最好是public的，private的构造函数无法进行初始化

复制构造函数：类内的一个成员函数，不能有返回值类型（void也不行），名字与类名同名，只有一个参数为 类名&形参对象名 ，即一个引用（不允许有形如 类名(类名 形参) 的构造函数）。没有定义时系统自动为类生成一个只有复制作用的复制构造函数

复制构造函数被自动调用的情景：

1. 类名 对象2=对象1;	//对象之间的等号赋值不会调用，只有初始化的等号会调用
2. 类名 对象2(对象1);
3. 这类的对象被作为参数复制后进入函数时	//为防止调用，可以将函数的参数设置为对象的引用，若要避免对实参的修改，可以使用常引用
4. 这类的对象在函数内得出后复制并被函数返回时

参数可以用const修饰，可接受的参数类型更多，且不修改传入的实参

类型转换构造函数：一种特殊的构造函数，非explicit修饰的函数均可作为复制构造函数

作用：如类型转换构造函数为：类名(int a){...}

当对类的对象c1进行：c1 = 9/c1={9,8}操作时，9/9和8会代入类型转换构造函数并自动生成一个临时的对象，并将这个对象赋值给c1（隐式）

防止这种隐式转换：类内定义时，在函数名前加explicit关键字

析构函数：类内的一个成员函数，不能有返回值类型（void也不行）也不能有参数，名字为类名前加一个~，没有定义时系统自动为类生成一个没有作用的构造函数

一个类只能有一个析构函数

析构函数在对象消亡时自动调用

对象作为函数参数时，在函数return后，复制传入的参数作为对象，消失时也会调用析构

对象作为返回值时，在函数生成了返回值临时对象并使用后，临时对象消失也会调用析构

（有些编译器为了优化而不生成返回值临时变量）

this指针：在非静态成员函数中，可用this表示函数所属对象的指针

静态成员：在前加static关键字的成员，不需要有实例化对象就可访问

静态成员变量：被所有该类的对象公用，不会算在sizeof中，静态成员变量必须在类外进行声明并可以初始化（加 类名:: 不加 static），否则编译可过但链接不可过

静态成员函数：普通成员函数必须作用于某个具体对象而静态成员函数无需，不能访问非静态成员变量和调用非静态成员函数，不能使用this指针

访问静态成员：除了常规方法之后，也可以直接：类名::成员

静态成员本质上是全局变量和全局函数，而写到类内的意义在于便于理解、维护、使用同时将类作为命名空间

只读对象/常量对象：实例化对象时在前加const

常量对象只能使用构造函数、析构函数和有const说明的函数（常量方法）

只读方法/常量方法：**定义**和**声明**时，在函数的 ()后{}前 加 const ，常量成员函数内部不能改非静态属性的值，也不能调用同类的非常量非静态成员函数

同名同返回值同参数的方法和常量方法构成重载，对象为常量对象时调用常量方法，否则调用普通方法

在属性前加上mutable关键字，则属性可以被常量方法修改和使用

构造函数的初始化列表：

初始化的顺序只取决于类内属性的声明顺序

调用构造函数是初始化的一个环节，先使用初始化器，再调用构造函数

`类名::构造函数(参数):成员变量1(参数,参数...), 成员变量2(参数,参数...){}`

初始化const成员、引用成员时必须使用初始化列表

成员变量为对象时，括号操作本质上是调用了相应的构造函数

对于普通变量，小括号可以换成大括号

默认初始化器：

在类内声明属性后再后面使用{}进行默认初始化

成员对象：一个类的对象作为另一个大类的成员变量

任何生成封闭类的语句，必须要让编译器明白如何初始化成员变量尤其是作为对象的成员变量，常用初始化列表

封闭类对象生成时，先执行成员对象的构造函数（按照在封闭类定义时的先后次序），再执行封闭类的构造函数；消亡时先执行封闭类的析构函数，在执行成员对象的析构函数且次序与构造函数相反

封闭类的复制构造函数执行复制操作时，成员对象也会运行复制构造函数

友元：friend

友元函数：在类内加入 friend 类外函数声明; 可以让类外函数访问类内的私有成员

可以将一个类的成员函数声明为另一个类的友元

友元类：在类内加入 friend 其他类的声明; 可以让其他类访问这类的私有成员，友元类关系不能传递和继承

friend int main()不会报错，但是会失去效果，main函数无法直接访问私有成员 

移动语义：

允许对象的资源在不深度复制的情况下进行转移，避免不必要的内存拷贝

左值：有固有地址的对象，可以在赋值中出现在等号左侧

右值（纯右值）：临时对象或字面量，通常不能取地址，出现在赋值语句右侧

左值引用：int&，只能由左值初始化，绑定到所指代对象的引用

右值引用：int&&，只能由右值初始化，绑定到所指代临时对象的引用

只读左值引用：可以绑定任意对象

临时对象在表达式执行完成后释放，但如果被引用绑定，生命会延长到右值引用释放

移动赋值运算符重载：

如：

```
String& operator=(String&& a)
{
   len = a.len;
   str = a.str;
   a.str = nullptr;
   return *this;
}
```
移动复制构造函数同理

继承：子类/派生类具有父类/基类的所有属性和方法，但不能访问父类的private成员

子类/派生类可以进行扩展和修改

语法：

class 子类名:派生方式说明符 父类名{};

使用同名成员进行覆盖后，在子类内使用作用域符号 :: 可以访问先前父类的非private属性/方法（父类名::父类属性/方法()），子类和子类的 友元都可以访问基类的protected成员

派生方式说明符：

公有继承public：父类所有成员保留其所有的权限继承到子类

私有继承private：父类的成员都以private权限继承到子类

保护继承protected：基类的公用和保护成员都以protected权限继承到子类

基类的构造函数、析构函数、赋值运算符重载不会被继承

写子类的构造函数时，初始化列表可以使用父类的public构造函数，从而解决了父类的private属性无法直接被子类修改的问题（不使用时会调用父类的默认的构造函数）

构造顺序：基类构造函数，成员对象构造函数，子类构造函数；析构与构造顺序相反

友元关系不会被传递

public继承的赋值兼容规则：

子类对象可以赋值给父类（转换时会调用基类的复制构造函数，赋值时会调用基类的赋值重载）；子类对象可以被基类引用；子类地址可以赋值给父类指针（但不能访问子类对象拓展出的成员，除非使用强制类型转换把指针类型改为子类的指针）

派生类的派生类会自动向上继承间接基类	

多继承：子类由多个父类继承而来

多继承的多个父类有同名函数时，即使函数类型不同也无法重载，只能使用 父类名::函数 来进行调用（在子类进行 using 父类名::函数名; 声明，可以直接将父类的函数声明下移到子类里，从而可以实现函数的重载）

多态机制：

虚函数：在类内的函数声明前加virtual关键字（只写在类内声明前，类外定义时不写）

通过基类对象指针调用基类和派生类的同名同参的虚函数，指针指向基类对象时调用基类的虚函数，指向派生类对象时调用派生类的虚函数

通过基类对象引用调用基类和派生类的同名同参的虚函数，引用基类对象时调用基类的虚函数，引用派生类对象时调用派生类的虚函数

在**基类的非构造非析构的成员函数**调用虚函数时，会触发多态机制

在**析构函数和构造函数**中，会调用自己的函数，不会触发多态（通过基类指针删除派生类对象时，一般只调用基类的析构函数，而将基类析构函数进行virtual声明，则可以实现删除时先调用基类析构函数再调用派生类析构函数（一般一个类定义了虚函数或一个类要作为基类使用时，析构函数都会进行virtual声明））

不允许有**构造函数**是虚函数

派生类若存在与基类的虚函数声明完全一致的普通函数，会自动转换为虚函数

多态的关键：动态联编：通过基类指针和引用调用一个虚函数时，编译时不确定调用基类还是派生类的函数，运行时才确定

动态联编的实现方式：使用虚函数表：每个有虚函数的类都有一个虚函数表，该类的任何对象都有一个虚函数表的指针，虚函数表列出了该类所有虚函数的地址；多态的函数调用语句被编译为根据基类指针所指向（或引用）的对象中存放的虚函数表的地址

纯虚函数：没有函数体的虚函数/函数声明后接 =0 的虚函数

抽象类：包含纯虚函数的类，只能用做基类，不能实例化对象，但可以使用抽象类的指针和引用来指向派生类；抽象类的成员函数可以调用纯虚函数，但是析构函数和构造函数不能调用纯虚函数；抽象类的派生类只有具体实现了基类所有纯虚函数后才成为非抽象类

override：加在派生类的虚函数后，防止在基类找不到对应的虚函数，如果找不到在编译时就会报错

final：效果override，不同的是派生类的派生类不再能够覆盖这一方法（final可以用于定义类时的类名后，表示这一类不能再被继承）

## 运行时类型识别（RTTI）：

C++只允许拥有虚函数的类使用RTTI

typeid运算符（需要使用`<typeinfo>`）：typeid(类名) 或 typeid(变量名/对象名)，同类的输入返回相同的值用于判断是否为某类



## 统一初始化

cpp中的多种初始化方式：

类型 数组变量名{值,值...}

类型 数组变量名={值,值...}

类型 变量名(值)

类型 变量名=值

统一初始化：所有数据类型都可以使用列表形式统一初始化，类型 变量名{值}

优点：防止窄缩：

char c1 = 11111		#警告

char c2{111}			#允许

char c3{11111}		#报错



## 函数指针

声明：如int (\*ptr)(int,int);，声明ptr为一个指向int(int,int)类型函数的指针

int (\*ptr\[n\])(int);，声明ptr为一组数组

调用函数：ptr=&函数名;  (\*ptr)(实参)

ptr=函数名 亦可：函数名可以隐式转换为函数指针（&函数名）

ptr(实参) 亦可：函数指针可以直接调用函数

形参中包含函数指针的函数称为高阶函数

## lambda表达式/lambda函数/匿名函数

实际上是一个重载了()运算符的匿名类的对象，构造函数作用为将捕获列表中的内容初始化进入这个类（捕获列表为空的lambda表达式可以隐式的转换为函数指针）

声明方式：

\[捕获列表\]\(参数表\) \-\> 返回值类型 函数体

返回值类型可以不写，由系统自动判断

关于捕获列表：

\[ \]不使用任何外部变量

\[=\]以传值的形式使用所有外部变量

\[&\]以引用形式使用所有外部变量

\[x, &y\] x 以传值形式使用，y 以引用形式使用

\[=, &x, &y\] x,y 以引用形式使用，其余变量以传值形式使用

\[&, x, y\] x,y 以传值的形式使用，其余变量以引用形式使用

捕获列表有内容时，lambda表达式不能由常规类型的函数指针承接，但是可以由auto类型的变量作为函数指针承接，如：`auto func = [](int a)->int{return a*a;};func(2);`

表达式最后可以直接跟()，表示直接调用，如： `cout<<[](int a)->int{return a*a;}(2)<<endl;`

表达式本身和函数名等价，可以作为调用也可以作为指针

## 运算符重载

使运算符对于不同类型的对象采取不同的操作，拓展运算符的适用范围，以用于抽象的类类型

常见运算符重载：>> << ++ --

运算符重载本质上是函数重载

语法：

`返回值类型 operator 运算符(形参){}`返回值类型尽量与原运算符保持一致，比如使用原数据类型的引用作为返回值

重载为成员函数时参数数量为运算符目数减一（前目为成员函数所在的对象本体）

=的重载：=只能重载为成员函数，用于实现赋值两边类型不匹配

没有在类内重载赋值运算符时，编译器会默认生成一个=的重载，效果是对每个成员变量进行赋值操作

（注意：当成员变量为指针时只能做到浅拷贝，即两个对象公用一块地址而不是复制了新的数据，此时需要手动定义）

同时包含相同参数类型的类型转换构造函数和赋值运算符重载时，优先使用重载的赋值运算符

留意自赋值情况：if(this\=\=&s)return \*this;

赋值与初始化的区别/调用重载赋值运算符和类型转换构造函数的时机：

1. 赋值是从1到1，初始化是从0到1
2. 声明和定义对象时初始化，执行赋值表达式时赋值
3. 接受函数的参数以及函数返回值时对象会被初始化而不是赋值

流运算符的重载：

cout本质上是一个iostream中定义的ostream类的对象，<<在其中被重载

一种实现方式：
```cpp
ostream& operator <<(ostream & o,Object a)
{
    Output(a);
    return o;
}

istream& operator >>(istream & i,Object a)
{
    i>>a.属性1>>a.属性2....;
    return i;
}
```

**类型转换运算符的重载**：

`operator 类型(){}`

只能重载为成员函数，不指定返回类型，没有形参，在类型转换时自动调用（使用explicit时则只能用于显式类型转换）

++/--的重载：

默认重载时，一目为前置，（加个没用的参数）二目为后置

函数调用运算符：()

只能重载为成员函数，使一个对象可以像函数一样()调用

重载了函数调用运算符的对象称为函数对象

函数对象：

1. lambda表达式，捕获列表实际上是private的成员变量
2. STL中的函数对象，定义在`<functional>`中

   运算类：`std::plus<>`，`std::minus<>`等

   比较类：`std::equal<>`，`std::greater<>`等

将函数对象作为参数传入时，参数类型的设置：可以使用模板；可以使用`<functional>`中的`std::function<>`，如`std::function<int(int)> F`，可以显式的限定传入函数对象的参数和返回值类型

其他：

\[\] \-\>只能重载为成员函数

. ?: :: sizeof .\* throw alignof不能重载 

不允许定义新的运算符

重载运算符必须至少有一个操作数是对象



## C++风格的类型转换

为了区分安全的和危险的转换，分清楚转换的职责，C++分解出了四种显式转换的关键字

语法：xxx\_cast<目标类型\>(想要转换的表达式);

static\_cast：基本安全的转换，涉及指针或引用的操作可能要注意一下安全性

dynamic\_cast：非常安全的转换，专用于继承与多态，开销稍微大一些

const\_cast：比较危险的转换，需要谨慎使用

reinterpret\_cast：非常危险的转换，需要程序员仔细思考它的功能

static\_cast：

1. 缩窄转换
2. 枚举的转换
3. 将基类指针或引用转换为派生类的指针或引用（须保证此时指向的确实是派生类）
4. 与void\*的转换等

dynamic\_cast：

在static\_\_cast的基础上，当将基类指针转换为派生类时会检查此时指向的内容，如果不是派生类则会返回空指针；将基类引用转换为派生类时也会检查，如果不是派生类则会抛异常

const\_cast：

通常出现在一个库的函数的某个参数忘记了const属性，事实上代码也并没有对它做修改，此时我们可以把手里的const A\* ptr强行通过 `const\_cast<A\*>(ptr)`提供给这个函数

如果内部是const对象，我们转型后对其修改一般是UB（未定义行为），结果未知

reinterpret\_cast：

各种指针引用随意转换，指针和整数的转换



## 泛型程序设计

编写代码时不使用具体的类型，而使用抽象的类型编写，实例化时再提供参数来指明类型

1. 使用模板（template）
1. 使用标准模板库STL

函数模板：提供生成函数能力的语法

template <模板形参表>

返回值类型 模板函数名(形参列表){函数体}

模板形参表：一系列逗号分隔的模板形参，返回值类型、形参、函数体中都可以用模板形参代替任意类型

1. 类型模板形参：typename 形参名 或 class 形参名
2. 非类型模板形参

c++20后，函数参数可以使用auto占位符，实际上是生成了参数为模板形参的函数模板

手动实例化：函数模板名<模板实参表>(实参列表)

自动实例化：实例化发生在调用了函数而先前没有实例化过这一类型的函数的时候（函数模板实参推导TAD）

无法自动推导引用类型和const类型，如需使用可以在模板中加入&符和const

函数模板可以重载，只要形参列表或者模板形参表不同即可

函数寻找顺序：

1. 先寻找一个函数名和参数列表完全相同的普通函数
2. 找不到，再寻找一个函数名和参数列表完全相同的实例化出来的函数
3. 再找不到，就在无二义性的前提下参数经过隐式类型转换后能匹配的普通函数
4. 还找不到，则报错

类模板：

template <模板形参表>

class 类模板名{类体}

类模板的成员函数在类外定义的方法：

template <模板形参表>

返回值类型 类模板名<模板形参名的列表>::成员函数名(函数形参表){函数体}

手动实例化：类模板名<模板实参表> 对象名(构造函数参数表)

自动实例化：类模板实参推导（CTAD）

类模板中的成员函数也可以是一个模板，此时实例化类时，不会实例化函数，函数被调用时才被实例化

类模板的派生：

1. 类模板派生类模板
2. 模板类派生类模板
3. 普通类派生类模板
4. 模板类派生普通类

非类型模板形参：将变量作为模板形参，用于替换模板中的变量

实例化是在编译过程中完成的，所以非类型模板形参必须为常量

形参写在模板与写在参数列表的区别：

模板函数每次实例化都是一个新函数，普通函数每次调用都是原来的函数；模板函数编译更复杂，但是运行时效率更高

模板特化：

针对某一模板中特定的模板形参类型，重新定义这种情况的新的模板

语法：（假如之前已经有了模板类cls的定义）

`template <>		#以这句为开头成为模板的全特化`

`class cls<int>{定义}`

即实现了对`cls<int>`的特化的定义


## 标准模板库

包含一些常用的数据结构和算法的模板

1. 存储数据：容器，是类模板
2. 读写数据：迭代器，类似于指针，至少具备自增++和解地址\*操作
3. 操作数据：算法，用于操作容器中元素的函数模板

### 容器

用于存放各种类型数据的数据结果，都是类模板

对象可以被插入容器，此时实际上插入的是对象的一个复制，会调用复制构造函数，操作不会改变原对象

三类容器：（前两类统称为第一类容器）

1. 顺序容器（序列容器）：vector，deque，list
1. 关联容器：set，multiset，map，multimap
1. 容器适配器：stack，queue，priority\_queue

顺序容器：

vector：头文件`<vector>`，动态数组（动态向量），随机存取任何元素都能在常数时间完成，在尾端增删元素具有较好的性能

vector实现二维数组：将vector作为模板实参，即`vector<vector<int>> v(3)`，即声明一个三个元素均为一维数组的vector

deque：头文件`<deque>`，双向队列，随机存取任何元素都能在常数时间完成（慢于vector），在两端增删元素都具有较好性能，存在push\_front()，pop\_front()方法

list：头文件`<list>`，双向链表，不支持随机存取，在任意位置增删元素都可以在常数时间完成

成员函数：

大部分容器具有的函数：

empty()：判断容器是否为空

max\_size()：返回容器可装的最大容量

size()：返回当前容器大小

swap()：交换容器内容

\=\= < >等按字典顺序比较的运算符

顺序容器常用函数：

front()：返回首项的引用

back()：返回尾项的引用

push\_back()：在末尾加一个元素

pop\_back()：删除末尾的元素

clear()：清空

关联容器：

有序关联容器：元素是有序排列的，插入和检索只需要o(logn)时间

set/multiset：`<set>`集合，multi可以存相同的元素

map/multimap：`<map>`映射，multi可以允许相同的key

无序关联容器：元素按照特定顺序（乱序）存放，插入和检索只需要o(1)时间

unordered\_set/unordered\_multiset：`<unordered_set>`

unordered\_map/unordered\_multimap：`<unordered_map>`

关联容器元素插入的位置取决于它的值，查找速度快

关联容器特有的一些成员函数：

find：查找等于某个值的元素，返回迭代器（y大于x和y小于x同时不成立即为相等）

lower\_bound：对传入的值，返回一个迭代器it，在\[begin(),it)中所有元素都比值小（下界）

upper\_bound：对传入的值，返回一个迭代器it，在\[it,end())中所有元素都比值大（上界）

equal\_range：同时查找上界和下界（返回`pair<iterator,iterator>`）

count：返回等于某值的元素个数

insert：插入一个元素并返回一个迭代器；将传入的两个迭代器之间（左闭右开）的片段插入容器

关联容器常用pair模板：`pair<T1,T2>`，为一个类模板，存储一个数据对，构造函数传入两个参数即可，成员变量为first和second

make\_pair(a,b)：返回一个构造出的pair对象（通常使用auto来接收）

multiset：

`template<typename Key,typename Pred=less<Key>>`

`class multiset{   };`

其中key表示元素类型，Pred表示multiset中的元素排列方式，默认为`less<key>`（所以需要类key重载过<运算符）

set：

同multi，插入时如果有相同元素则会忽略插入

multimap：

每个元素都是一个pair对象，由键值对组成，是按照键的顺序默认进行`less<Key>`排列的

multimap不支持\[ \]运算符

map：

支持[ ]运算符，`pair[键]=值`，如果存在这个键就返回其对应值的引用，如何不存在就会创建这样一个键值对

容器适配器：

通过封装某个顺序容器，重新组合成员函数，使其满足某些特定场景的需要

栈stack：`<stack>`，后进先出，删除检索修改插入只能对队尾操作

队列queue：`<queue>`，先进先出，插入只能在队尾，删除只能在队首，检索和修改可以在队首或队尾

优先级队列priority\_queue：`<queue>`，按优先级顺序出列

stack：

`template<typename T,typename Cont=deque<T>>`

`class stack{   };`

三种容器实现默认用deque实现，用vector和deque实现的效果比list效果更好

成员函数：push，pop，top（返回栈顶的引用）

queue：

可用两种容器实现，默认deque，可用list

成员函数：push，pop，top（返回队头），back（返回队尾）

priority\_queue：

同queue，但模板形参有第三项，默认为`less<T>`，是用来优先级排列的可调用对象

迭代器：用于指向顺序容器和关联容器中的元素，用法与指针类似

只要定义了\*it和it++这两个合法表达式，就可以成为迭代器

定义语法：（由于名字过长，一般定义时类型写为auto自动推导）

容器类名::iterator 迭代器变量名

容器类名::const\_iterator 迭代器变量名（不能改变内容，可以改变指向）

访问所指向的元素：\*迭代器名

++操作：指向容器中的下一个函数，指向末尾的后面时，再使用就会报错（野指针）

迭代器相关的成员函数：

begin：返回指向开头的迭代器

end：返回指向最后一个元素的下一个位置的迭代器

rbegin：返回指向最后一个元素的迭代器

rend：返回指向开头的上一个位置的迭代器

erase(迭代器)：删除所指的元素并返回删除位置的下一个位置的迭代器

insert(const\_iterator p,值)：在指向的元素之前插入一个值

迭代器根据强度不同的分类：

1. 输入迭代器：Input iterators 提供对数据的只读访问；输出迭代器：Output iterators 提供对数据的只写访问 
2. 前向迭代器：Forward iterators 提供读写操作，并能一次一个地向前推进迭代
3. 双向迭代器：Bidirectional iterators 提供读写操作，并能一次一个地向前和向后移动
4. 随机访问迭代器：Random access iterators 提供读写操作，并能在数据中随机移动
5. 连续迭代器：Contiguous iterator提供读写操作，并能在数据中随机移动，相邻的容器元素在内存中物理相邻

不同强度迭代器的功能：

所有迭代器：++p，p++

输入迭代器：通过\*p读取数据

输出迭代器：通过\*p修改数据

前向迭代器：以上全部，以及p\=\=q，p!=q

双向迭代器：以上全部，以及--p，p--

随机访问迭代器：以上全部，以及：

移动i个单元：p+= i, p -= i, p + i, p - i

大于/小于比较：p < q, p <= q, p > q, p>= q

下标p\[i\]：p后面的第i个元素的引用

连续迭代器：以上全部，以及p-q恰好是其所指向的元素的地址的差



### 算法库

大多数都在`<algorithm>`和`<numeric>`里定义

都是函数模板，实际上是通过迭代器对容器（以及c语言的数组）进行操作

许多算法需要两个参数：起始位置的迭代器和末尾位置的下一个位置的迭代器（排序和查找）

基于迭代器实现通用的算法（即可使用于不同的容器），大概70多种，如：通用的bubbleSort()函数，只要迭代器可以前向迭代即可

sort(a,b,可调用对象)：排序函数，从地址a到地址b左闭右开，前后两个值的可调用对象值为false时进行交换

可调用对象：能出现在()左侧的对象

1. 函数
2. 函数指针
3. 可转换到函数指针的对象
4. 重载了`operator()`的对象（即函数对象）（如对象模板生成的模板类`great<int>()`（STL中的函数对象模板，需要导入`<functional>`））
5. lambda表达式

list不支持sort（因为list的迭代器未实现小于号的定义），所以list对象自己存在一个成员函数，默认无参数，也可以传入一个可调用对象作为排序标准

find(a,b,值)：在a到b地址左闭右开上寻找值，返回所在的地址（迭代器），找不到则返回b

max()：求最大值，可以max(a,b)，也可以max({a,b,c,d…})

copy(开始迭代器,结束迭代器,存储位置迭代器)：左闭右开，将之间的内容一个一个复制到存储位置中；若存储位置的容器空间为空或不足以存储，可以使用追加：存储位置迭代器写为back\_insertor(容器名)（需要导入`<iterator>`头文件），实际上是重载了copy函数源代码中的=运算符

copy\_if()：比copy多了一个第四参数，为一个可调用对象，对每一个待复制的值，可调用对象返回true时进行复制

transform()：参数同copy\_if()，将待复制的每一个值经过可调用对象作用后再进行复制

accumulate(开始迭代器,结束迭代器,初始值,可调用对象)：对每一个元素，进行操作：值=可调用对象(值,一个元素)，得到新的值后对下一个元素继续操作直到最后。accumulate存在于`<numeric>`中

主要七种算法：

不变序列算法：此类算法不会修改算法所作用的容器或对象，适用于所有容器，它们的时间复杂度都是O(n)

变值算法：此类算法会修改源区间或目标区间元素的值。值被修改的那个区间，不可以是属于关联容器的

删除算法：删除一个容器里的某些元素

变序算法：改变容器中元素的顺序，但是不改变元素的值。不适用于关联容器。此类算法复杂度都是O(n)

排序算法：算法复杂度一般是O(n×log(n))。需要随机访问迭代器的支持，因而不适用于关联容器和list

有序区间算法：要求所操作的区间是已经从小到大排好序的，而且需要随机访问迭代器的支持

数值算法：进行各类数值运算



## 数据成员指针

指向数据成员的指针，持有某一数据成员相对于整个对象的**地址偏移量**

对于结构体struct S { int a, b; };，指针值 &S::b 就代表了成员 b 在整个 S 中的偏移量

声明存储数据成员指针的变量：声明这样的变量的方法是 T S::\*mem 初始化器，其中 T 是成员的类型，S 是类（结构体）名，mem 是变量名

如：初始化指针变量 ptr 持有成员 S::a 偏移量的初始化声明写成：int S::\*ptr = &S::a;。

可以通过 .\* 运算符或 ->\* 运算符使用成员指针。如：对于对象 S obj;，obj.\*ptr 即可访问到 obj.a 成员



## 形参包

typename... 包名

可以接受任意数量的实参，在模板中可以使用 ...包名 进行包展开

包展开只能在特定的语境中使用：函数/模板实参列表、部分初始化器

如：
```cpp
template <typename T, typename... Types>
T sum(Types... args);
```


## 类型特征

元编程库的一部分，用于结合模板判断类型接口

使用库`<type_traits>`

常用函数如：

`std::is_integral_v<T>`判断类型T是否为整数类型

`std::is_abstract_v<T>`判断类型T是否为抽象类

`std::is_copy_assignable_v<T>`判断类型是否有复制赋值运算符

`std::is_floating_point_v<T>`判断类型是否为浮点数

`std::is_pointer_v<T>`判断是否为指针

`constexpr if`语句：编译时检查

如：
```cpp
template<typename T>
auto get_value(T t)
{
   if (std::is_pointer_v<T>)
      return *t;
   else
      return t;
}
```


## 输入输出流与迭代器

istream是用于输入的流类，cin就是该类的对象

ostream是用于输出的流类，cout就是该类的对象

ifstream是用于从文件读取数据的类

ofstream是用于向文件写入数据的类

iostream是既能用于输入，又能用于输出的类

fstream是既能从文件读取数据，又能向文件写入数据的类

istream和ostream以ios为基类，ifstream和ofstream分别以前两者作为基类，iostream以istream和ostream作为基类，fstream以iostream作为基类

cin：与标准输入设备相连，对应标准输入流，用于从键盘读取数据，也可以被重定向为从文件中读取数据

cout：与标准输出设备相连，对应标准输出流，用于向屏幕输出数据，也可以重定向为向文件中写入数据

cerr：与标准错误输出设备相连

clog：与标准错误输出设备相连

cerr不使用缓冲区，直接向显示器输出信息，而clog会先放到缓冲区，缓冲区满或刷新时才会输出到屏幕

while(cin>>x)在输入Ctrl+Z时会跳出：istream类重载了explict operator bool类型转换运算符

istream类成员函数：

istream& getline(char\* buf,int bufsize)：从输入流中读取bufsize-1个运算符或读取到\n

istream& getline(char\* buf,int bufsize,char delim)：同上，读取到delim停止

bool eof()：判断输入流是否结束

int peek()：返回下一个字符，但是不从流中去掉（窥探）

isteam& putback(char ch)：将字符ch放回输出流

流操纵算子/流控制符：`<iomanip>`

整数流的基数：

dec：十进制输出数字

hex：十六进制

oct：八进制

setbase(n)：设置n进制

浮点数精度：

setprecision(n)：设置有效精确数字位数（cout.prcision()可以返回当前的精度）

setiosflags(x)：流格式操纵算子（x为std::fixed：将setprecision的意义修改为小数点后的位数；x为std::fixed|ios::showpoint：有showpoint时即使没有小数部分也会额外多一个点）

设置域宽：

setw(n)：设置每次输出宽度，不足用空格补足（右对齐，若设置左对齐，则在前方加left算子）（cout.width()返回当前宽度）

setfill(ch)：将不足时补足的字符改为ch

自定义流操纵算子：如：

ostream &tab(ostream &output)

{return output<<'\t';}

原理：iostream中重载了ostream& operator<<(ostream&(\*p)(ostream&))（iomanip的流操作算子就是这样定义的函数）

输入输出迭代器：

类模板std::istream\_iterator用于定义输入迭代器对象

定义：`istream_iterator<int> inputInt(输入流如cin)`，即从输入流中读取一个数据并保存到其中

可以使用>>从输入流读入连续的元素

\*运算符/->运算符：获取保存的数据

++运算符：再从输入流中读取一个数据并保存到其中

支持\=\=，!=

类模板std::ostream\_iterator用于定义输出迭代器对象

定义：`ostream_iterator<int> outputInt(输出流如cout)`，即向输出流写入元素（括号中可以写第二实参，一个字符串，表示每次输出元素的间隔字符）

可以使用<<将连续的元素写入输出流

支持\*，++，\*后赋值即为输出



## 概念concept

C++20新加入的特性，本质上是对模板参数进行限制，如：
```cpp
//自定义迭代器概念：要有迭代器类型、begin接口、end接口，且接口返回值都是这一迭代器类型
template<typename T>
concept Iteratable = requires (T a) {
   typename T::iterator;
   {a.begin()} -> std::same_as<typename T::iterator>;
   {a.end()} -> std::same_as<typename T::iterator>;
};
```
```cpp
//自定义可加概念：要可以加、赋值、加等于
template<typename T>
concept Addable = requires (T a, T b) {
   a + b;
   a += b;
   a = b;
};
```

控制传入的模板参数必须满足一些条件，如果不满足，在未编译前的静态检查就会报错，并且编译时的错误信息也会更准确直接

使用自定义的概念：

```cpp
template <Iteratable Container, Addable Value>
int sum(const Container& container, Value res){
   for(const auto& value: container){
      res += value;
   }
   return res;
}
```

STL中自带`<concept>`库



## 范围range

C++20引入，并为此修改了algorithm中的相关算法，范围算法定义在命名空间std::ranges::中，传入容器时无需再传入两个迭代器，而是只传入一个范围，如容器名表示其包含的所有范围

视图：范围 | 视图，其中 | 称为管道操作符，用于创造视图对象

常用视图：（命名空间为std::views::）

reverse（反转），take(n)（访问前n个），transform(f)（将每个x视为f(x)）,filter(f)（）只有f(x)\=\=true时才访问

也可以直接构造视图对象：（命名空间为std::ranges::）

reverse\_view，take\_view，transform\_view，filter\_view，构造时传入范围或视图对象



## 工程的分文件管理

整体代码拆分为多个代码文件后，当修改某个代码文件时，只需重新编译改过的文件并重新链接即可，整体的翻译效率得到提升

函数的分文件编写/多文件编写：

1，另创建.h拓展名的头文件

2，另创建.cpp拓展名的源文件

3，在头文件里写声明（头文件开头写上需要引用的头文件，如：`#include <iostream>`）

4，在源文件里写定义（源文件开头写上：`#include "头文件名称"`，双引号表示此头文件为自定义的文件）

5，最后在核心项目源文件开始处加上`#include "头文件名称"`

（头文件修改后，所有include了这个头文件的文件都要重新编译，所以要尽可能将内容写在.cpp中而令.h中的内容尽可能确定不变）

多文件共享变量：

在一个文件定义非只读变量，其他文件使用extern声明这个变量的存在即可

在一个文件定义只读变量，其他文件使用`extern const`声明这个变量存在即可

一个正常的多文件工程组织格式：

.h/.hpp：头文件，写类定义、模板定义、函数声明、static变量声明（不同拓展名无实际区别）

.cpp：源文件，写类方法的定义、函数定义、static变量定义



## 预处理指令

#include：

把某个文件直接复制插入所在位置，如果内容还有include就会递归插入；<>文件优先在系统库内寻找，""优先在当前源文件所在的路径中寻找

多次include同样的定义会造成报错，需要使用预处理指令

#if #elif #else #endif：
```cpp
#if 常量表达式 //（如：\_\_cplusplus >=201103L，检查cpp版本）（如：defined 宏，返回是否定义了这个宏）
代码1
#elif 常量表达式
代码2
#else
代码3
#endif
```
#ifdef #ifndef：相当于#if defined #if !defined

#define 宏 内容：定义宏

常用的避免重定义的方法：
```cpp
#ifndef 宏
#define 宏
代码
#endif
```


## 命令行main函数传参与程序传参

在命令行中输入：exe文件的文件名 参数1 参数2 ...

参数会以字符串的形式传入程序

main函数可以设置两个参数：`int argc`和`char** argv`，`argc`为传入参数的个数，包括传入的程序名；`argv[0]`即为可执行程序名，从`[1]`开始即为传入的字符串类型的参数

命令行重定向输入输出：

可执行文件名 > 文件名：将标准输出设置为向此文件进行输出

可执行文件名 < 文件名：将标准输入设置为从此文件中读入

（Windows的PowerShell不支持这种重定向）



## 命令行控制编译、make、cmake

编译指令：

g++ ./main.cpp ./a.cpp... -o ./main.exe

其中-o表示编译后的文件的存储路径

g++通过文件拓展名来判断编译起点位于什么阶段，通过若干其他选项控制停止在哪里

如：

-E：将预处理作为最后一步，得到预处理后的文件（-E并不由-o控制输出位置而是直接输出到屏幕即stdout上，所以可以使用重定向运算符>改变输出位置生成.ii文件）

-S：将编译作为最后一步，得到汇编文件.s

-c：将汇编作为最后一步，得到对象文件.o

不含以上选项：将链接作为最后一步，得到可执行文件.exe

GNU Make：简称Make，一种构建工具

构建：指在一个项目中安排编译的顺序、时机、最终目标Target

Make使用文件makefile（无拓展名）指明构建方法

makefile格式：
```makefile
目标文件名:依赖文件1 依赖文件2...

   命令行生成指令（这句话之前是一个Tab即\t，而不是若干空格）
```
在命令行界面执行makefile文件即可完成编译，Make会通过每个文件的最后更改时间自动判断每次生成是否需要重新编译

CMake：通过一个CMakeList.txt的脚本来生成makefile（Linux系统）/.sln（Windows），跨平台，开源

CMake可以自动查找系统上已经安装的库和头文件如Boost、QT、OpenCV

常用CMake语句：

cmake\_minimum\_required(VERSION 3.18.0)：规定最低的CMake版本

project(HelloWorld)：指定项目名称

add\_executable(main main.cpp f.cpp g.cpp)：生成一个名为main的可执行文件，由其后的几个文件编译链接得到



## 文件读写

顺序文件：将所有记录顺序的写入一个文件中

可以将顺序文件看作一个有限字符构成的顺序字符流，像对cin cout一样读写

C++风格的文件读写：使用`<fstream>`

创建文件对象：

ofstream 对象名("打开路径名",ios::out)（第二个参数可缺省，默认为out；out为删除原有内容重新写入，app为在尾部追加写，ate为在任意位置插入添加）（路径找不到则创建该文件）

ifstream 对象名("打开路径名",ios::in)（第二个参数可缺省，默认为in）

或

ofstream 对象名;

对象名.open("打开对象名",打开方式);

文件的读写指针：

成员函数：

.tellp()：返回一个long型整数，指明当前指针所在字节数

.seekp(long)：第一参数为一个long型整数且可以为负数，表示将指针指向第long个字节处；存在第二参数，默认为ios::beg，beg为从头数，cur为从当前位置数，end为从结尾数（专用于ofsteam）

.seekg()：与seekp类似，专用于ifstream

关闭文件：

.close()

几乎任何情形都不需要手动关闭流对象，因为这会在对象析构的时候自动进行



## 智能指针

代表一种所有权的概念，表示拥有资源的权力和销毁资源的权力

可以替代动态内存分配中所有的new，并且不需要delete

（RAII资源管理方法：从构造函数中获得，从析构函数中释放，如智能指针、string、iofstream自动关闭等）

通过函数的规约来判断使用何种指针：

裸指针：使用而非占有，不改变指向对象的生命周期，可以对指向的对象进行读写

`unique_ptr<T>`：调用者放弃指针指向对象的所有权，交给函数处理，函数会暂时拥有对象的所有权，函数退出后自动析构

`unique_ptr<T>&`：传入一个函数后通常是希望修改`unique_ptr`本身，即给`unique_ptr`设置一个新的拥有对象

`share_ptr`：表达若干个对象对一个资源的共享（在所有对象都不再需要这个资源的时候才会delete），共享资源时应该使用复制构造函数（=）进行拷贝构造从而进行引用计数器的加减（或者使用`make_shared`函数进行拷贝）

不能将裸指针赋值给`unique_ptr`或对其进行初始化，因为`unique_ptr`一定掌握了所指向资源的所有权且只有自己可以析构它

成员函数：

reset()：把当前持有的资源delete，不填参数则赋值nullptr，有参数则将此参数作为自己持有的新资源

.release()：会把所有权释放掉（不是delete），把自己赋值为nullptr并把之前持有的指针作为返回值返回

.get()：返回持有的指针



## 防御性编程

防御性编程常用技术：输入检查、断言、错误处理、异常处理、隔栏

输入检查：

1. 检查所有来源于外部的数据（文件、用户输入、网络、其他外部接口）
2. 检查函数的所有输入参数值是否满足规约的前置条件（参数类型、值是否合法、长度是否符合要求）

断言：在开发期间使用的让程序运行时自检的代码，用来检查不该发生的情况

断言为真说明程序运行正常，断言为假说明程序运行错误

断言只在开发时使用，生成产品时并不编译到产品代码中

C++中的断言：在头文件`<cassert>`中定义了assert宏

语法：assert(表达式)，表达式为false时程序会终止运行，并输出“源文件，错误的代码、行序号”

在源文件起始位置加入#define NDEBUG可停用assert

断言的使用：

1. 在函数开始时检查传入参数的合法性
2. 最好每个assert只检查一个条件便于更好定位
3. 不要再断言中使用改变数据的语句，因为断言只会再debug阶段下生效

错误处理：

理想情况：希望在发生错误情况时，不只是简单地终止程序运行，而是能够反馈错误情况的信息，并且能够对程序运行中已发生的事情做些处理

异常：

当一个函数出现自己无法处理的错误时，可以抛出异常，然后由该函数的直接或者间接调用者处理这个错误

异常处理：

抛异常：throw 表达式，表达式可以是一个基本类型也可以是一个类

捕获异常：
```
try{语句}
catch(异常类型){异常处理语句}
```
异常类型填写 ... 表示捕获任意类型的异常，通过控制抛出的异常类型来判断使用哪句catch后的语句

抛出异常对象后会生成一个异常对象的拷贝（调用复制构造）

catch的查找规则：

1. 首先检查throw语句本身是否在try块内部，如果是，再在当前函数栈中查找匹配的catch语句
2. 如果有匹配的直接跳到catch的地方执行
3. 如果没有匹配的catch块或者throw语句不在try块内部，则退出当前函数栈，在调用函数的栈中查找匹配的catch
4. 如果到达main函数，都没有匹配的catch，就会终止程序
5. 找到匹配的catch会直接跳到catch语句执行，执行完后，会继续沿着catch语句后面执行

C++标准异常类：

如：

bad\_alloc：new内存分配时没有足够的内存可以分配	

out\_of\_range：用vector或string的at成员函数根据下标访问元素时，如果下标越界，就会抛出此异常




## 琐碎的语法

EOF：文件结束的标志，end of file

toupper()函数：将小写字符类型转换为大写字符类型

memcpy(p1,p2,n)：`<memory>`库中的函数，将p2的n个字节的内存拷贝到p1



## ASCII码表（AI生成，编译查询）

| Dec | Hex | Char | Dec | Hex | Char | Dec | Hex | Char | Dec | Hex | Char |
|-----|-----|------|-----|-----|------|-----|-----|------|-----|-----|------|
| 000 | 00  | NUL  | 064 | 40  | @    | 128 | 80  | �    | 192 | C0  | └    |
| 001 | 01  | SOH  | 065 | 41  | A    | 129 | 81  | �    | 193 | C1  | ┴    |
| 002 | 02  | STX  | 066 | 42  | B    | 130 | 82  | �    | 194 | C2  | ┬    |
| 003 | 03  | ETX  | 067 | 43  | C    | 131 | 83  | �    | 195 | C3  | ├    |
| 004 | 04  | EOT  | 068 | 44  | D    | 132 | 84  | �    | 196 | C4  | ─    |
| 005 | 05  | ENQ  | 069 | 45  | E    | 133 | 85  | …    | 197 | C5  | ┼    |
| 006 | 06  | ACK  | 070 | 46  | F    | 134 | 86  | †    | 198 | C6  | ╞    |
| 007 | 07  | BEL  | 071 | 47  | G    | 135 | 87  | ‡    | 199 | C7  | ╟    |
| 008 | 08  | BS   | 072 | 48  | H    | 136 | 88  | ˆ    | 200 | C8  | ╚    |
| 009 | 09  | TAB  | 073 | 49  | I    | 137 | 89  | ‰    | 201 | C9  | ╔    |
| 010 | 0A  | LF   | 074 | 4A  | J    | 138 | 8A  | Š    | 202 | CA  | ╩    |
| 011 | 0B  | VT   | 075 | 4B  | K    | 139 | 8B  | ‹    | 203 | CB  | ╦    |
| 012 | 0C  | FF   | 076 | 4C  | L    | 140 | 8C  | Œ    | 204 | CC  | ╠    |
| 013 | 0D  | CR   | 077 | 4D  | M    | 141 | 8D  | �    | 205 | CD  | ═    |
| 014 | 0E  | SO   | 078 | 4E  | N    | 142 | 8E  | Ž    | 206 | CE  | ╬    |
| 015 | 0F  | SI   | 079 | 4F  | O    | 143 | 8F  | �    | 207 | CF  | ╧    |
| 016 | 10  | DLE  | 080 | 50  | P    | 144 | 90  | �    | 208 | D0  | ╨    |
| 017 | 11  | DC1  | 081 | 51  | Q    | 145 | 91  | ‘    | 209 | D1  | ╤    |
| 018 | 12  | DC2  | 082 | 52  | R    | 146 | 92  | ’    | 210 | D2  | ╥    |
| 019 | 13  | DC3  | 083 | 53  | S    | 147 | 93  | “    | 211 | D3  | ╙    |
| 020 | 14  | DC4  | 084 | 54  | T    | 148 | 94  | ”    | 212 | D4  | ╘    |
| 021 | 15  | NAK  | 085 | 55  | U    | 149 | 95  | •    | 213 | D5  | ╒    |
| 022 | 16  | SYN  | 086 | 56  | V    | 150 | 96  | –    | 214 | D6  | ╓    |
| 023 | 17  | ETB  | 087 | 57  | W    | 151 | 97  | —    | 215 | D7  | ╫    |
| 024 | 18  | CAN  | 088 | 58  | X    | 152 | 98  | ˜    | 216 | D8  | ╪    |
| 025 | 19  | EM   | 089 | 59  | Y    | 153 | 99  | ™    | 217 | D9  | ┘    |
| 026 | 1A  | SUB  | 090 | 5A  | Z    | 154 | 9A  | š    | 218 | DA  | ┌    |
| 027 | 1B  | ESC  | 091 | 5B  | [    | 155 | 9B  | ›    | 219 | DB  | █    |
| 028 | 1C  | FS   | 092 | 5C  | \    | 156 | 9C  | œ    | 220 | DC  | ▄    |
| 029 | 1D  | GS   | 093 | 5D  | ]    | 157 | 9D  | �    | 221 | DD  | ▌    |
| 030 | 1E  | RS   | 094 | 5E  | ^    | 158 | 9E  | ž    | 222 | DE  | ▐    |
| 031 | 1F  | US   | 095 | 5F  | _    | 159 | 9F  | Ÿ    | 223 | DF  | ▀    |
| 032 | 20  | SP   | 096 | 60  | `    | 160 | A0  | NBSP | 224 | E0  | α    |
| 033 | 21  | !    | 097 | 61  | a    | 161 | A1  | ¡    | 225 | E1  | ß    |
| 034 | 22  | "    | 098 | 62  | b    | 162 | A2  | ¢    | 226 | E2  | Γ    |
| 035 | 23  | #    | 099 | 63  | c    | 163 | A3  | £    | 227 | E3  | π    |
| 036 | 24  | $    | 100 | 64  | d    | 164 | A4  | ¤    | 228 | E4  | Σ    |
| 037 | 25  | %    | 101 | 65  | e    | 165 | A5  | ¥    | 229 | E5  | σ    |
| 038 | 26  | &    | 102 | 66  | f    | 166 | A6  | ¦    | 230 | E6  | µ    |
| 039 | 27  | '    | 103 | 67  | g    | 167 | A7  | §    | 231 | E7  | τ    |
| 040 | 28  | (    | 104 | 68  | h    | 168 | A8  | ¨    | 232 | E8  | Φ    |
| 041 | 29  | )    | 105 | 69  | i    | 169 | A9  | ©    | 233 | E9  | Θ    |
| 042 | 2A  | *    | 106 | 6A  | j    | 170 | AA  | ª    | 234 | EA  | Ω    |
| 043 | 2B  | +    | 107 | 6B  | k    | 171 | AB  | «    | 235 | EB  | δ    |
| 044 | 2C  | ,    | 108 | 6C  | l    | 172 | AC  | ¬    | 236 | EC  | ∞    |
| 045 | 2D  | -    | 109 | 6D  | m    | 173 | AD  | ­    | 237 | ED  | φ    |
| 046 | 2E  | .    | 110 | 6E  | n    | 174 | AE  | ®    | 238 | EE  | ε    |
| 047 | 2F  | /    | 111 | 6F  | o    | 175 | AF  | ¯    | 239 | EF  | ∩    |
| 048 | 30  | 0    | 112 | 70  | p    | 176 | B0  | °    | 240 | F0  | ≡    |
| 049 | 31  | 1    | 113 | 71  | q    | 177 | B1  | ±    | 241 | F1  | ±    |
| 050 | 32  | 2    | 114 | 72  | r    | 178 | B2  | ²    | 242 | F2  | ≥    |
| 051 | 33  | 3    | 115 | 73  | s    | 179 | B3  | ³    | 243 | F3  | ≤    |
| 052 | 34  | 4    | 116 | 74  | t    | 180 | B4  | ´    | 244 | F4  | ⌠    |
| 053 | 35  | 5    | 117 | 75  | u    | 181 | B5  | µ    | 245 | F5  | ⌡    |
| 054 | 36  | 6    | 118 | 76  | v    | 182 | B6  | ¶    | 246 | F6  | ÷    |
| 055 | 37  | 7    | 119 | 77  | w    | 183 | B7  | ·    | 247 | F7  | ≈    |
| 056 | 38  | 8    | 120 | 78  | x    | 184 | B8  | ¸    | 248 | F8  | °    |
| 057 | 39  | 9    | 121 | 79  | y    | 185 | B9  | ¹    | 249 | F9  | ·    |
| 058 | 3A  | :    | 122 | 7A  | z    | 186 | BA  | º    | 250 | FA  | ·    |
| 059 | 3B  | ;    | 123 | 7B  | {    | 187 | BB  | »    | 251 | FB  | √    |
| 060 | 3C  | <    | 124 | 7C  | \|   | 188 | BC  | ¼    | 252 | FC  | ⁿ    |
| 061 | 3D  | =    | 125 | 7D  | }    | 189 | BD  | ½    | 253 | FD  | ²    |
| 062 | 3E  | >    | 126 | 7E  | ~    | 190 | BE  | ¾    | 254 | FE  | ■    |
| 063 | 3F  | ?    | 127 | 7F  | DEL  | 191 | BF  | ¿    | 255 | FF  | NBSP |